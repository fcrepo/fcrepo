<infinispan xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="urn:infinispan:config:5.2 http://www.infinispan.org/schemas/infinispan-config-5.2.xsd"
            xmlns="urn:infinispan:config:5.2">

  <global>

    <globalJmxStatistics enabled="true" allowDuplicateDomains="true"/>

    <!-- Defines the global settings shared by all caches -->
    <transport clusterName="modeshape-cluster">
      <properties>
        <property name="configurationFile" value="${fcrepo.ispn.jgroups.configuration:config/jgroups-fcrepo-tcp.xml}"/>
      </properties>
    </transport>
  </global>

  <default>
    <!--
       Defines the default behavior for all caches, including those created dynamically (e.g., when a
       repository uses a cache that doesn't exist in this configuration).
     -->
    <clustering mode="distribution">
      <sync/>
      <l1 enabled="false" lifespan="0" onRehash="false"/>
      <hash numOwners="${fcrepo.ispn.numOwners:2}"/>
      <stateTransfer chunkSize="100" fetchInMemoryState="true"/>
    </clustering>
  </default>

  <namedCache name="FedoraRepository">
    <!--
        Our Infinispan cache needs to be transactional. However, we'll also configure it to
        use pessimistic locking, which is required whenever applications will be concurrently
        updating nodes within the same process. If you're not sure, use pessimistic locking.
     -->
    <clustering mode="replication">
      <sync/>
      <stateTransfer chunkSize="100" fetchInMemoryState="true"/>
    </clustering>

    <locking concurrencyLevel="1000" lockAcquisitionTimeout="15000" useLockStriping="false" />

    <deadlockDetection enabled="true" spinDuration="1000"/>


    <eviction maxEntries="500"  strategy="LIRS" threadPolicy="DEFAULT"/>

    <transaction
        transactionManagerLookupClass="org.infinispan.transaction.lookup.GenericTransactionManagerLookup"
        transactionMode="TRANSACTIONAL" lockingMode="PESSIMISTIC"/>
    <!--
        Define the cache loaders (i.e., cache stores). Passivation is false because we want *all*
        data to be persisted, not just what doesn't fit into memory. Shared is false because there
        are no other caches sharing this file store. We set preload to false for lazy loading;
        may be improved by preloading and configuring eviction.

        We can have multiple cache loaders, which get chained. But we'll define just one.
     -->

    <loaders passivation="false" shared="false" preload="false">

      <!--
         The 'fetchPersistentState' attribute applies when this cache joins the cluster; the value doesn't
         really matter to us in this case. See the documentation for more options.
       -->
      <loader class="org.infinispan.loaders.file.FileCacheStore" fetchPersistentState="true"
              purgeOnStartup="false">
        <!-- See the documentation for more configuration examples and flags. -->
        <properties>
          <!-- We have to set the location where we want to store the data. -->
          <property name="location" value="${fcrepo.ispn.repo.CacheDirPath:target/FedoraRepository/storage}"/>

          <property name="fsyncMode" value="perWrite"/>
        </properties>
        <!-- This repository isn't clustered, so we could set up the SingletonStore.
         singletonStore enabled="true" pushStateWhenCoordinator="true" pushStateTimeout="20000"/>
         -->
        <!--
           We could use "write-behind", which actually writes to the file system asynchronously,
           which can improve performance as seen by the JCR client.
           Plus changes are coalesced, meaning that if multiple changes are enqueued for the
           same node, only the last one is written. (This is good much of the time, but not
           always.)
         <async enabled="true" flushLockTimeout="15000" threadPoolSize="5"/>
         -->
      </loader>

    </loaders>
  </namedCache>

  <namedCache name="FedoraRepositoryMetaData">
    <!--
        Our Infinispan cache needs to be transactional. However, we'll also configure it to
        use pessimistic locking, which is required whenever applications will be concurrently
        updating nodes within the same process. If you're not sure, use pessimistic locking.
     -->
    <clustering mode="replication">
      <sync/>
      <stateTransfer chunkSize="100" fetchInMemoryState="true"/>
    </clustering>

    <locking concurrencyLevel="1000" lockAcquisitionTimeout="15000" useLockStriping="false" />

    <deadlockDetection enabled="true" spinDuration="1000"/>


    <eviction maxEntries="500"  strategy="LIRS" threadPolicy="DEFAULT"/>

    <transaction
            transactionManagerLookupClass="org.infinispan.transaction.lookup.GenericTransactionManagerLookup"
            transactionMode="TRANSACTIONAL" lockingMode="PESSIMISTIC"/>
    <!--
        Define the cache loaders (i.e., cache stores). Passivation is false because we want *all*
        data to be persisted, not just what doesn't fit into memory. Shared is false because there
        are no other caches sharing this file store. We set preload to false for lazy loading;
        may be improved by preloading and configuring eviction.

        We can have multiple cache loaders, which get chained. But we'll define just one.
     -->

    <loaders passivation="false" shared="false" preload="false">

      <!--
         The 'fetchPersistentState' attribute applies when this cache joins the cluster; the value doesn't
         really matter to us in this case. See the documentation for more options.
       -->
      <loader class="org.infinispan.loaders.file.FileCacheStore" fetchPersistentState="true"
              purgeOnStartup="false">
        <!-- See the documentation for more configuration examples and flags. -->
        <properties>
          <!-- We have to set the location where we want to store the data. -->
          <property name="location" value="${fcrepo.ispn.CacheDirPath:target/FedoraRepositoryMetaData/storage}"/>

          <property name="fsyncMode" value="perWrite"/>
        </properties>
        <!-- This repository isn't clustered, so we could set up the SingletonStore.
         singletonStore enabled="true" pushStateWhenCoordinator="true" pushStateTimeout="20000"/>
         -->
        <!--
           We could use "write-behind", which actually writes to the file system asynchronously,
           which can improve performance as seen by the JCR client.
           Plus changes are coalesced, meaning that if multiple changes are enqueued for the
           same node, only the last one is written. (This is good much of the time, but not
           always.)
         <async enabled="true" flushLockTimeout="15000" threadPoolSize="5"/>
         -->
      </loader>

    </loaders>
  </namedCache>

  <namedCache name="FedoraRepositoryBinaryData">
    <!--
        Our Infinispan cache needs to be transactional. However, we'll also configure it to
        use pessimistic locking, which is required whenever applications will be concurrently
        updating nodes within the same process. If you're not sure, use pessimistic locking.
     -->
    <clustering mode="distribution">
      <sync replTimeout="${fcrepo.ispn.replication.timeout:10000}" />
      <l1 enabled="false" lifespan="0" onRehash="false"/>
      <hash numOwners="${fcrepo.ispn.numOwners:2}" numSegments="40"/>
      <stateTransfer chunkSize="100" fetchInMemoryState="true"/>
    </clustering>

    <locking concurrencyLevel="1000" lockAcquisitionTimeout="15000" useLockStriping="false" />

    <deadlockDetection enabled="true" spinDuration="1000"/>


    <eviction maxEntries="100"  strategy="LIRS" threadPolicy="DEFAULT"/>

    <transaction
            transactionManagerLookupClass="org.infinispan.transaction.lookup.GenericTransactionManagerLookup"
            transactionMode="TRANSACTIONAL" lockingMode="PESSIMISTIC"/>
    <!--
        Define the cache loaders (i.e., cache stores). Passivation is false because we want *all*
        data to be persisted, not just what doesn't fit into memory. Shared is false because there
        are no other caches sharing this file store. We set preload to false for lazy loading;
        may be improved by preloading and configuring eviction.

        We can have multiple cache loaders, which get chained. But we'll define just one.
     -->

    <loaders passivation="false" shared="false" preload="false">

      <!--
         The 'fetchPersistentState' attribute applies when this cache joins the cluster; the value doesn't
         really matter to us in this case. See the documentation for more options.
       -->
      <loader class="org.infinispan.loaders.file.FileCacheStore" fetchPersistentState="true"
              purgeOnStartup="false">
        <!-- See the documentation for more configuration examples and flags. -->
        <properties>
          <!-- We have to set the location where we want to store the data. -->
          <property name="location" value="${fcrepo.ispn.binary.CacheDirPath:target/FedoraRepositoryBinaryData/storage}"/>

          <property name="fsyncMode" value="perWrite"/>
        </properties>
        <!-- This repository isn't clustered, so we could set up the SingletonStore.
         singletonStore enabled="true" pushStateWhenCoordinator="true" pushStateTimeout="20000"/>
         -->
        <!--
           We could use "write-behind", which actually writes to the file system asynchronously,
           which can improve performance as seen by the JCR client.
           Plus changes are coalesced, meaning that if multiple changes are enqueued for the
           same node, only the last one is written. (This is good much of the time, but not
           always.)
         <async enabled="true" flushLockTimeout="15000" threadPoolSize="5"/>
         -->
      </loader>

    </loaders>
  </namedCache>
</infinispan>
